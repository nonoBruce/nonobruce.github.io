{"meta":{"title":"好大一棵树的博客","subtitle":"","description":"","author":"好大一棵树","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2019-12-09T12:41:47.000Z","updated":"2019-12-09T13:10:07.782Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"我是天边的一片云，偶尔投影到你的波心"},{"title":"文章分类","date":"2019-09-02T17:40:32.000Z","updated":"2019-09-02T17:41:25.358Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-09-02T17:43:13.000Z","updated":"2019-09-02T17:44:17.995Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hexo Next 配置","slug":"2019/Hexo/Hexo Next 配置","date":"2019-12-08T16:00:00.000Z","updated":"2019-12-20T17:05:02.045Z","comments":true,"path":"2019/12/09/2019/Hexo/Hexo Next 配置/","link":"","permalink":"http://yoursite.com/2019/12/09/2019/Hexo/Hexo%20Next%20%E9%85%8D%E7%BD%AE/","excerpt":"2019-12-09 把 Hexo 的主题改为 了 Next 了 主题设置下载主题 12$ cd 主目录&#x2F;git clone --branch v7.6.0 https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next 配置主题 主目录-&gt;_config.yml 1theme: next 配置评论系统 valine查看如何配置 valine https://valine.js.org/quickstart.html","text":"2019-12-09 把 Hexo 的主题改为 了 Next 了 主题设置下载主题 12$ cd 主目录&#x2F;git clone --branch v7.6.0 https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next 配置主题 主目录-&gt;_config.yml 1theme: next 配置评论系统 valine查看如何配置 valine https://valine.js.org/quickstart.html 一、获取 leanCloud 获取APP ID 和 APP Key参考链接 二、配置安全域名参考链接 三、修改主题下面的配置在 themes-&gt;next-reloaded-&gt;_config.xml 下编辑 enable 设置为 true 配置 appid 和 appkey 在设置下 placeholder 访客数量 visitor 1234567891011121314valine: enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version appid: xxxxxxxxxxxxxxxxx-xxxxxxx appkey: xxxxxxxxxxxxxxxxx notify: false # Mail notifier. See: https:&#x2F;&#x2F;github.com&#x2F;xCss&#x2F;Valine&#x2F;wiki verify: false # Verification code placeholder: Comment ... # Comment box placeholder avatar: mm # Gravatar style guest_info: nick,mail # Custom comment header pageSize: 10 # Pagination size language: # Language, available values: en, zh-cn visitor: true # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors&#39; for counter compatibility. Article reading statistic https:&#x2F;&#x2F;valine.js.org&#x2F;visitor.html comment_count: true # If false, comment count will only be displayed in post page, not in home page #post_meta_order: 0 主题设置为 Gemini1scheme: Gemini 菜单设置123456menu: home: &#x2F; || home categories: &#x2F;categories&#x2F; || th archives: &#x2F;archives&#x2F; || archive tags: &#x2F;tags&#x2F; || tags about: &#x2F;about&#x2F; || user 存在问题Next 新版本，分页有问题 在本地可以正常，部署到 github 上就不行了，提示第二页找不到了 更多配置查看Hexo Next 配置 或者 https://theme-next.iissnan.com/theme-settings.html","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"iOS 红点设计","slug":"2019/iOS/iOS红点设计","date":"2019-12-08T16:00:00.000Z","updated":"2019-12-12T17:05:57.097Z","comments":true,"path":"2019/12/09/2019/iOS/iOS红点设计/","link":"","permalink":"http://yoursite.com/2019/12/09/2019/iOS/iOS%E7%BA%A2%E7%82%B9%E8%AE%BE%E8%AE%A1/","excerpt":"实现方式用树结构实现红点提示 树的层级结构和 UI 的层级结构对应。 当叶节点红点更新的时候，需要更新叶节点到根节点这条路径上的所有节点的红点数据（这个路径可能会有多条–通常红点页面可能有多个入口） 节点设计树节点的设计 1、红点数量 2、子节点列表 3、父节点列表 当一个叶节点的红点发生了变化，则遍历叶节点到根节点的路径，更新所有的红点数据。","text":"实现方式用树结构实现红点提示 树的层级结构和 UI 的层级结构对应。 当叶节点红点更新的时候，需要更新叶节点到根节点这条路径上的所有节点的红点数据（这个路径可能会有多条–通常红点页面可能有多个入口） 节点设计树节点的设计 1、红点数量 2、子节点列表 3、父节点列表 当一个叶节点的红点发生了变化，则遍历叶节点到根节点的路径，更新所有的红点数据。 展示情况UI 节点的展示有3种情况 数值 小红点 无 优先级设定： 1、数值&gt;0 显示数值2、小红点&gt;0 显示小红点3、不显示 12345678910int count &#x3D; 评论数 + 赞数;if (count &gt; 0) &#123; 展示数字count&#125;else if (有系统消息) &#123; 展示红点&#125;else &#123; 隐藏数字和红点&#125; #其他的情况有时，一个页面可能有多个地方的入口，就需要 参考： https://blog.csdn.net/uniqsa/article/details/77884650 http://zhangtielei.com/posts/blog-badge-number-tree.html","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"iOS RunLoop 苹果文档和简单翻译","slug":"2019/iOS/RunLoop","date":"2019-04-24T16:00:00.000Z","updated":"2019-12-09T12:46:11.471Z","comments":true,"path":"2019/04/25/2019/iOS/RunLoop/","link":"","permalink":"http://yoursite.com/2019/04/25/2019/iOS/RunLoop/","excerpt":"苹果文档： Run Loops 概述 Run Loops 详情 本篇主要是看下苹果的文档描述，作下简单的翻译。 Run Loops 概述A run loop is a piece of infrastructure used to manage events arriving asynchronously on a thread. A run loop works by monitoring one or more event sources for the thread. As events arrive, the system wakes up the thread and dispatches the events to the run loop, which then dispatches them to the handlers you specify. If no events are present and ready to be handled, the run loop puts the thread to sleep. RunLoop 是线程管理异步事件到达的基础结构，RunLoop 为线程监听一个或者多个事件源。当事件到达时，系统唤醒线程并把事件交给 RunLoop 去处理。如果没有事件到达或者需要处理，RunLoop 就会让线程休眠。","text":"苹果文档： Run Loops 概述 Run Loops 详情 本篇主要是看下苹果的文档描述，作下简单的翻译。 Run Loops 概述A run loop is a piece of infrastructure used to manage events arriving asynchronously on a thread. A run loop works by monitoring one or more event sources for the thread. As events arrive, the system wakes up the thread and dispatches the events to the run loop, which then dispatches them to the handlers you specify. If no events are present and ready to be handled, the run loop puts the thread to sleep. RunLoop 是线程管理异步事件到达的基础结构，RunLoop 为线程监听一个或者多个事件源。当事件到达时，系统唤醒线程并把事件交给 RunLoop 去处理。如果没有事件到达或者需要处理，RunLoop 就会让线程休眠。 You are not required to use a run loop with any threads you create but doing so can provide a better experience for the user. Run loops make it possible to create long-lived threads that use a minimal amount of resources. Because a run loop puts its thread to sleep when there is nothing to do, it eliminates the need for polling, which wastes CPU cycles and prevents the processor itself from sleeping and saving power. 你无须为任何线程创建一个 RunLoop ，但是通过它可以给用户更好的体验。RunLoop 可以使用最小的资源创建一个常驻线程，因为 RunLoop 可以使线程在无事可做的时候休眠，所以它消除轮询的需求。（这会浪费CPU周期，并阻止机器本身休眠，节省电力） To configure a run loop, all you have to do is launch your thread, get a reference to the run loop object, install your event handlers, and tell the run loop to run. The infrastructure provided by OS X handles the configuration of the main thread’s run loop for you automatically. If you plan to create long-lived secondary threads, however, you must configure the run loop for those threads yourself. 配置一个 RunLoop ，你需要做的就是起一个线程，引用到 RunLoop 对象，注册时间处理器，告诉 RunLoop 运行。如果是需要创建一个常驻的子（次要）线程，你必须配置你的线程。 Details about run loops and examples of how to use them are provided in Run Loops. Run Loops 详情","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"RunLoop","slug":"RunLoop","permalink":"http://yoursite.com/tags/RunLoop/"}]},{"title":"iOS RunLoop 与 NSTimer","slug":"2019/iOS/RunLoop与NSTimer","date":"2019-04-24T16:00:00.000Z","updated":"2019-12-16T11:37:55.656Z","comments":true,"path":"2019/04/25/2019/iOS/RunLoop与NSTimer/","link":"","permalink":"http://yoursite.com/2019/04/25/2019/iOS/RunLoop%E4%B8%8ENSTimer/","excerpt":"","text":"RunLoopRunLoop 是线程管理异步事件到达的基础结构，RunLoop 为线程监听一个或者多个事件源。当事件到达时，系统唤醒线程并把事件交给 RunLoop 去处理。如果没有事件到达或者需要处理，RunLoop 就会让线程休眠。 RunLoop ModesRunLoop 有 5 种 ModeNSDefaultRunLoopMode (kCFRunLoopDefaultMode) 默认Mode，通常会使用这个UITrackingRunLoopMode 在ScrollView 滑动的时候会切换到这个 ModeNSRunLoopCommonModes 是一个占位的 ModeUIInitializationRunLoopMode 应用启动 会使用的 Mode，一般不可以手动调用GSEventReceiveRunLoopMode 接受内部事件的 Mode，一般不可以手动调用 NSTimer 的循环引用参考资料苹果文档","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"RunLoop","slug":"RunLoop","permalink":"http://yoursite.com/tags/RunLoop/"}]},{"title":"GCD dispatch_sync 锁死","slug":"2018/iOS/GCDdispatch_sync锁死","date":"2018-12-02T16:00:00.000Z","updated":"2019-12-14T01:05:46.400Z","comments":true,"path":"2018/12/03/2018/iOS/GCDdispatch_sync锁死/","link":"","permalink":"http://yoursite.com/2018/12/03/2018/iOS/GCDdispatch_sync%E9%94%81%E6%AD%BB/","excerpt":"dispatch_sync Submits a block to the specified dispatch queue for synchronous execution. Unlike dispatch_async, this function does not return until the block has finished. Calling this function and targeting the current queue results in deadlock. 调用 dispatch_sync 的时候不要把 block 任务添加到当前的 queue 中，否则会锁死(不要把 block 任务同步的加到当前的队列中，否则会锁死) 前提是这个 queue 是 serial 的（DISPATCH_QUEUE_SERIAL） main_queue 锁死在主线程调用 123456NSLog(@&quot;Hello 1&quot;);dispatch_queue_t queue &#x3D; dispatch_get_main_queue();dispatch_sync(queue, ^()&#123; NSLog(@&quot;Hello 2&quot;);&#125;);NSLog(@&quot;Hello 3&quot;); 会锁死线程，这里的block不会被执行到，Hello 2 和 Hello 3 都不会被打印。","text":"dispatch_sync Submits a block to the specified dispatch queue for synchronous execution. Unlike dispatch_async, this function does not return until the block has finished. Calling this function and targeting the current queue results in deadlock. 调用 dispatch_sync 的时候不要把 block 任务添加到当前的 queue 中，否则会锁死(不要把 block 任务同步的加到当前的队列中，否则会锁死) 前提是这个 queue 是 serial 的（DISPATCH_QUEUE_SERIAL） main_queue 锁死在主线程调用 123456NSLog(@&quot;Hello 1&quot;);dispatch_queue_t queue &#x3D; dispatch_get_main_queue();dispatch_sync(queue, ^()&#123; NSLog(@&quot;Hello 2&quot;);&#125;);NSLog(@&quot;Hello 3&quot;); 会锁死线程，这里的block不会被执行到，Hello 2 和 Hello 3 都不会被打印。 1、dispatch_sync 是当自身任务（block）执行完成之后才会回调； 2、main_queue（Serial Dispatch Queue）serial queue 中任务是一个完成后才能执行下一个任务； 3、当 dispatch_sync 在主线程往 main_queue 的添加 block 任务 即 block 任务添加到 main_queue 的队尾，也就是放到当前任务的后面执行 但是 dispatch_sync 会阻塞当前线程，让线程先去执行 block 任务，但是在 block 任务也在 main_queue 的尾部 因为执行 main_queue 的线程被阻塞了，就永远执行不到 block 任务了，就锁住了。 当然在其他子线程调用这个是不会锁死的。 一般 queue 锁死同样的在其他（serial的）queue 中，只要 dispatch_sync 的任务 block，是被加入当前的 queue 中都会被锁死。所以一般不要在嵌套里面放 dispatch_sync什么是当前的 queue 呢？即当前在执行的 queue，我在说啥？ 下面例子的 queue 都是 DISPATCH_QUEUE_SERIAL 类型的 queue例子： 123456dispatch_async(queue, ^&#123;&#x2F;&#x2F;block1 NSLog(@&quot;do something 1&quot;); dispatch_sync(queue, ^&#123;&#x2F;&#x2F;block2 NSLog(@&quot;do something 2&quot;); &#125;);&#125;); 内层的 block2 通过 dispatch_sync 添加到 queue 中 执行 queue 的线程被 dispatch_sync 叫去执行 block2 但是 block2 也在 queue 的末尾，必须先执行 queue 前面的任务 但是 queue 被 dispatch_sync 阻塞了，就锁住了 例子直接参考这个链接 12345678910111213141516171819202122232425262728293031&#x2F;&#x2F;Situation 1 - OKdispatch_async(queue, ^&#123; [self goDoSomethingLongAndInvolved]; dispatch_async(queue, ^&#123; NSLog(@&quot;Situation 1&quot;); &#125;);&#125;);&#x2F;&#x2F;Situation 2 - Not OK! Deadlock!dispatch_sync(queue, ^&#123; [self goDoSomethingLongAndInvolved]; dispatch_sync(queue, ^&#123; NSLog(@&quot;Situation 2&quot;); &#125;);&#125;);&#x2F;&#x2F;Situation 3 - Not OK! Deadlock!dispatch_async(queue, ^&#123; [self goDoSomethingLongAndInvolved]; dispatch_sync(queue, ^&#123; NSLog(@&quot;Situation 3&quot;); &#125;);&#125;);&#x2F;&#x2F;Situation 4 - OKdispatch_sync(queue, ^&#123; [self goDoSomethingLongAndInvolved]; dispatch_async(queue, ^&#123; NSLog(@&quot;Situation 4&quot;); &#125;);&#125;); 参考地址苹果文档对 dispatch_sync 的解释：https://developer.apple.com/documentation/dispatch/1452870-dispatch_sync 里面有句，Submits a block to the specified dispatch queue for synchronous execution. Unlike dispatch_async, this function does not return until the block has finished. Calling this function and targeting the current queue results in deadlock. 知乎上的讨论 https://www.zhihu.com/question/23338200 有个关于嵌套 dispatch_sync 的讨论 https://stackoverflow.com/questions/19180661/sync-dispatch-on-current-queue https://www.jianshu.com/p/103097585ca0","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"GCD","slug":"GCD","permalink":"http://yoursite.com/tags/GCD/"},{"name":"GCD 死锁","slug":"GCD-死锁","permalink":"http://yoursite.com/tags/GCD-%E6%AD%BB%E9%94%81/"}]},{"title":"iOS block","slug":"2018/iOS/iOS block","date":"2018-10-02T16:00:00.000Z","updated":"2019-12-12T17:08:18.614Z","comments":true,"path":"2018/10/03/2018/iOS/iOS block/","link":"","permalink":"http://yoursite.com/2018/10/03/2018/iOS/iOS%20block/","excerpt":"Block参考书本：Objective-C 高级编程 Block 概要什么是Blockblock 是 C 语言的扩充功能，带有自动变量（局部变量）的匿名函数。 Block 定义^返回值类型 参数列表 表达式 123^int (int count)&#123; return count+1;&#125; 其中“返回值类型”和“参数列表”是可以省略的 和 C 语言的普通函数项相比 1、没有函数名称 2、带有^","text":"Block参考书本：Objective-C 高级编程 Block 概要什么是Blockblock 是 C 语言的扩充功能，带有自动变量（局部变量）的匿名函数。 Block 定义^返回值类型 参数列表 表达式 123^int (int count)&#123; return count+1;&#125; 其中“返回值类型”和“参数列表”是可以省略的 和 C 语言的普通函数项相比 1、没有函数名称 2、带有^ Block 作为变量Block 作为变量和普通的变量是一样的 1、自动变量（局部变量） 2、函数参数 3、静态变量 4、静态全局变量 5、全局变量 可以使用 typedef 定义一个Block 1typedef int (^block_t)(int); Block 可以捕获局部变量例子 1234567891011int main() &#123; int dmy &#x3D; 256; int val &#x3D; 10; void (^blk)(void) &#x3D; ^&#123; printf(&quot;val 1 &#x3D; %d&quot;, val); &#125; val &#x3D; 2; blk(val) printf(&quot;val 2 &#x3D; %d&quot;, val);&#125; 输出结果 12val 1 &#x3D; 10val 2 &#x3D; 10 __block__block 修饰的局部变量 可以在 block 表达式里面修改 如果局部变量是一个NSMutableArray或者其他的可变集合类的对象 1234567NSMutableArray arr &#x3D; [[NSMutalbeArray alloc] init];void (^blk)(void) &#x3D; ^&#123; NSObject *obj1 &#x3D; [[NSObject alloc] init]; [arr addObject:obj1];&#x2F;&#x2F;这个是可以添加变量 &#125; Block 本质block 常见问题 1、block的原理是怎样的？本质是什么？ 2、__block的作用是什么？有什么使用注意点？ 3、block的属性修饰词为什么是copy？使用block有哪些使用注意？ 4、block在修改NSMutableArray，需不需要添加__block？","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"iOS/基础知识","slug":"iOS-基础知识","permalink":"http://yoursite.com/tags/iOS-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"iOS Twitter 登录","slug":"2019/iOS/Twitter登录","date":"2018-08-26T16:00:00.000Z","updated":"2019-12-09T12:46:19.832Z","comments":true,"path":"2018/08/27/2019/iOS/Twitter登录/","link":"","permalink":"http://yoursite.com/2018/08/27/2019/iOS/Twitter%E7%99%BB%E5%BD%95/","excerpt":"一些参考地址： Twitter官网地址 TwitterSDK获取，工程配置 Twitter登录接入 Twitter遇到问题,可以在Twitter工程的Issues里搜索","text":"一些参考地址： Twitter官网地址 TwitterSDK获取，工程配置 Twitter登录接入 Twitter遇到问题,可以在Twitter工程的Issues里搜索 接入Twitter具体查看上面链接 创建应用1、创建应用进入网址：https://apps.twitter.com/ 创建应用，获得key，secret，勾选Allow this application to be used to Sign in with Twitter 2、在Callback URLs添加 twitterkit-consumerkey://不然会返回下面的错误 12[TwitterKit] Error obtaining user auth token.error: Request failed: forbidden (403) 具体查看地址 工程配置1、库文件导入这个链接里，获取SDKTwitterSDK获取下载引入库文件 123TwitterCore.frameworkTwitterKit.frameworkTwitterKitResources.bundle 需要而外添加 1234SafariServices.framework&#x2F;&#x2F;如果工程配置了Other Linker Flags为-ObjC的话需要添加下面两个库文件CoreLocation.frameworkMapKit.framework 2、Info.plist配置配置URL types和LSApplicationQueriesSchemes 1234567891011121314&lt;key&gt;CFBundleURLTypes&lt;&#x2F;key&gt;&lt;array&gt; &lt;dict&gt; &lt;key&gt;CFBundleURLSchemes&lt;&#x2F;key&gt; &lt;array&gt; &lt;string&gt;twitterkit-&lt;consumerKey&gt;&lt;&#x2F;string&gt; &lt;&#x2F;array&gt; &lt;&#x2F;dict&gt;&lt;&#x2F;array&gt;&lt;key&gt;LSApplicationQueriesSchemes&lt;&#x2F;key&gt;&lt;array&gt; &lt;string&gt;twitter&lt;&#x2F;string&gt; &lt;string&gt;twitterauth&lt;&#x2F;string&gt;&lt;&#x2F;array&gt; 如图： 代码调用一、SDK初始化在Appdelegate里添加 123- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString *,id&gt; *)options &#123; return [[Twitter sharedInstance] application:app openURL:url options:options];&#125; TwitterSDK初始化，要在调用登录之前调用 1[[TWTRTwitter sharedInstance] startWithConsumerKey:@&quot;6UFxIZuZIhAy4Mi8xxxxxxxx&quot; consumerSecret:@&quot;MmOJhdd13jR5a3TmEpey5RdXVXBG6qNJZpES4rFXhxxxxxxxx&quot;]; 二、使用Twitter按钮登录1234567891011TWTRLogInButton *logInButton &#x3D; [TWTRLogInButton buttonWithLogInCompletion:^(TWTRSession *session, NSError *error) &#123; if (session) &#123; NSLog(@&quot;signed in as %@&quot;, [session userName]); NSLog(@&quot;signed in as %@&quot;, [session userID]); NSLog(@&quot;signed in as %@&quot;, [session authToken]); NSLog(@&quot;signed in as %@&quot;, [session authTokenSecret]); &#125; else &#123; NSLog(@&quot;error: %@&quot;, [error localizedDescription]); &#125;&#125;]; 三、使用自定义Button123456789101112131415161718192021222324252627- (IBAction)loginWithTwitter:(UIButton *)sender &#123; TWTRSession *session &#x3D; [[Twitter sharedInstance] sessionStore].session; if(session) &#123; &#x2F;&#x2F;如果已经授权过了，判断session是否为空，直接返回用户信息。 NSLog(@&quot;userName &#x3D; %@&quot;, [session userName]); NSLog(@&quot;userID &#x3D; %@&quot;, [session userID]); NSLog(@&quot;authToken &#x3D; %@&quot;, [session authToken]); NSLog(@&quot;authTokenSecret &#x3D; %@&quot;, [session authTokenSecret]); self-&gt;_userId &#x3D; [session userID]; return; &#125; [[Twitter sharedInstance] logInWithCompletion:^(TWTRSession *session, NSError *error) &#123; if (session) &#123; NSLog(@&quot;userName &#x3D; %@&quot;, [session userName]); NSLog(@&quot;userID &#x3D; %@&quot;, [session userID]); NSLog(@&quot;authToken &#x3D; %@&quot;, [session authToken]); NSLog(@&quot;authTokenSecret &#x3D; %@&quot;, [session authTokenSecret]); self-&gt;_userId &#x3D; [session userID]; &#125; else &#123; NSLog(@&quot;error: %@&quot;, [error localizedDescription]); &#125; &#125;];&#125; 四、注销账号Twitter账号注销 12345- (IBAction)logout:(id)sender &#123; if(_userId) &#123; [[[Twitter sharedInstance] sessionStore] logOutUserID:_userId]; &#125;&#125; 常见问题如果在Other Linker Flags里面添加了-ObjC就会出现下面这个错误解决办法就是单独对需要加-ObjC标记的库，单独引用使用-force_load+framewrok目录-force_load$(PROJECT_DIR)/xxx/xxx/xxx.framework/xxx 或者添加 12CoreLocation.frameworkMapKit.framework 错误提示如下 123456789Undefined symbols for architecture x86_64: &quot;_OBJC_CLASS_$_CLLocationManager&quot;, referenced from: objc-class-ref in TwitterKit(TWTRSETweetComposerViewController.o) &quot;_OBJC_CLASS_$_MKMapView&quot;, referenced from: objc-class-ref in TwitterKit(TWTRSELocationMapTableViewHeaderView.o) &quot;_MKCoordinateRegionMakeWithDistance&quot;, referenced from: -[TWTRSELocationMapTableViewHeaderView initWithCenterCoordinates:] in TwitterKit(TWTRSELocationMapTableViewHeaderView.o)ld: symbol(s) not found for architecture x86_64clang: error: linker command failed with exit code 1 (use -v to see invocation)","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"SDK","slug":"SDK","permalink":"http://yoursite.com/tags/SDK/"}]},{"title":"Hexo-Yilia中添加gitment评论功能","slug":"2017/hexo-gitment","date":"2017-10-17T07:09:55.000Z","updated":"2019-12-09T12:45:09.822Z","comments":true,"path":"2017/10/17/2017/hexo-gitment/","link":"","permalink":"http://yoursite.com/2017/10/17/2017/hexo-gitment/","excerpt":"Gitment是使用的GitHub Issues作为评论系统 Gitment","text":"Gitment是使用的GitHub Issues作为评论系统 Gitment 一、在GitHub上创建OAuth Apps地址 如下图： 二、修改_config.yml在themes-&gt;yilia-&gt;_config.yml中修改如下 123456#5、Gitmentgitment_owner: &#39;nonoBruce&#39; #你的 GitHub IDgitment_repo: &#39;nonobruce.github.io&#39; #存储评论的 repogitment_oauth: client_id: &#39;92b923359ac16dxxxxxx&#39; #client ID client_secret: &#39;499f01cdb673aacac9211c4529f74xxxxx&#39; #client secret gitment_repo使用Repository name","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"Hexo中使用图片和音乐","slug":"2017/Hexo中使用图片和音乐","date":"2017-10-16T08:24:59.000Z","updated":"2019-12-09T12:45:00.358Z","comments":true,"path":"2017/10/16/2017/Hexo中使用图片和音乐/","link":"","permalink":"http://yoursite.com/2017/10/16/2017/Hexo%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87%E5%92%8C%E9%9F%B3%E4%B9%90/","excerpt":"categories: hexo 一、图片插入 使用hexo-asset-image来显示图片 Git地址 1、博客根目录输入 1npm install hexo-asset-image --save 2、博客根目录修改_config.yml配置文件post_asset_folder项为 true。 3、创建文章的时候会在source/_posts生成相同名字的文件夹，用来存放图片文件","text":"categories: hexo 一、图片插入 使用hexo-asset-image来显示图片 Git地址 1、博客根目录输入 1npm install hexo-asset-image --save 2、博客根目录修改_config.yml配置文件post_asset_folder项为 true。 3、创建文章的时候会在source/_posts生成相同名字的文件夹，用来存放图片文件 4、使用 1234![“图片描述”（可以不写）](&#x2F;你的图片名字.JPG)例如：![](shu.jpg) 5、或者使用HTML标签显示 1&lt;img src&#x3D;&quot;shu.jpg&quot;&gt; 6、gif同图片 1![gif](gif.gif) 二、播放音乐 浏览器打开网易云音乐，搜索想要的歌曲，点击歌曲名字进入播放器页面，点击“生成外链播放器”。复制到这边就可以了 1&lt;iframe frameborder&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; marginwidth&#x3D;&quot;0&quot; marginheight&#x3D;&quot;0&quot; width&#x3D;280 height&#x3D;86 src&#x3D;&quot;https:&#x2F;&#x2F;music.163.com&#x2F;outchain&#x2F;player?type&#x3D;2&amp;id&#x3D;437292675&amp;auto&#x3D;0&amp;height&#x3D;66&quot;&gt;&lt;&#x2F;iframe&gt; 三、视频 使用iframe标签 123456&lt;iframe height&#x3D;498 width&#x3D;510 autoPlay&#x3D;false src&#x3D;&quot;https:&#x2F;&#x2F;player.youku.com&#x2F;embed&#x2F;XNjcyMDU4Njg0&quot; frameborder&#x3D;0 allowfullscreen&gt; &lt;&#x2F;iframe&gt;","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"Hello World","slug":"2017/hello-world","date":"2017-10-13T16:00:00.000Z","updated":"2019-12-09T12:45:16.438Z","comments":true,"path":"2017/10/14/2017/hello-world/","link":"","permalink":"http://yoursite.com/2017/10/14/2017/hello-world/","excerpt":"Hello World!","text":"Hello World! Hello！Is anyone there？ 安装，配置项目1、安装brew 1&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot; 查看 1https:&#x2F;&#x2F;github.com&#x2F;Homebrew&#x2F;install 2、安装npm 1brew install node 3、安装hexo 1npm install -g hexo-cli hexo.io hexo 常见命令hexo部署 1234hexo cleanhexo generate 简写 hexo ghexo server 简写 hexo shexo deploy 简写 hexo d 如果遇到 1ERROR Deployer not found: github 解决办法 1npm install hexo-deployer-git --save 百度统计配置配置好的地址：https://tongji.baidu.com 百度统计配置参考地址","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"},{"name":"读书","slug":"读书","permalink":"http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6/"}]},{"title":"写 iOS SDK 注意事项","slug":"2016/iOS/写 iOS SDK 注意事项","date":"2016-04-26T16:00:00.000Z","updated":"2019-12-15T15:39:35.323Z","comments":true,"path":"2016/04/27/2016/iOS/写 iOS SDK 注意事项/","link":"","permalink":"http://yoursite.com/2016/04/27/2016/iOS/%E5%86%99%20iOS%20SDK%20%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","excerpt":"一、SDK 中所有的类名都应该加前缀包括 Catogery，Protocal等前缀可以是公司名称的简称，最好是三个字符（XSH） 二、尽量不要引入公用第三方的库1、 第三放库一般比较大，而SDK中使用的一般只是一小部分，可以自己重写一个轻量的、比如网络请求部分2、第三方库可能会有维护的问题3、可能会和调用SDK工程的冲突重复 三、提供的方法的易用性、简洁性1、方法要“望文生义”2、尽可能的减少接口和参数的数量。实现相同的功能的时候要尽量减少用户的操作，即减少方法的调用，能不用用户调用就不要让用户调用，能不让用户操作就不要让用户操作，自己内部解决。","text":"一、SDK 中所有的类名都应该加前缀包括 Catogery，Protocal等前缀可以是公司名称的简称，最好是三个字符（XSH） 二、尽量不要引入公用第三方的库1、 第三放库一般比较大，而SDK中使用的一般只是一小部分，可以自己重写一个轻量的、比如网络请求部分2、第三方库可能会有维护的问题3、可能会和调用SDK工程的冲突重复 三、提供的方法的易用性、简洁性1、方法要“望文生义”2、尽可能的减少接口和参数的数量。实现相同的功能的时候要尽量减少用户的操作，即减少方法的调用，能不用用户调用就不要让用户调用，能不让用户操作就不要让用户操作，自己内部解决。 四、提供debug模式，输出必要的日志，特别是错误日志，且提供处理这个错误具体步骤例子：比如用户没有配置plist里面内容，不要只提示不能获取xx，而是要提示：不能获取xx、请在info.plist中添加key为xxx value为xxx。可以用alert提示，或者log提示。个人喜欢用自定义的alert提示，这样接入的时候，开发者就一定会发现问题。如果只是用log的他们可能不会注意到。 五、充分测试要写一个测试文档，每次要测试的按顺序测试 六、提供模拟器的支持即使调用了第三方的SDK不支持模拟器，也可以通过判断是否为模拟器环境而决定要不要调用来提供支持 12345#if TARGET_IPHONE_SIMULATOR&#x2F;&#x2F;模拟器 #elif TARGET_OS_IPHONE&#x2F;&#x2F;真机 #endif 七、向下兼容新版本SDK的API要兼容旧版本的API，在旧的API要加上deprecated，并提醒加入方这个是在未来某个时候是会弃用了，尽量使用新的API。 八、不要太频繁的更新如果SDK太频繁的更新，会让开发者不爽。 九、尽量使Andriod和iOS的接口一致关于iOS和Android的一些对外接口方法，宏定义，尽量相同。有可能接入SDK的是一个人，熟悉了一套后，接入第二个平台就快点了。 十、提供完成的例子、文档1、所有的对外的方法，注意事项都要写出来2、按照文档，可以一步一步的走完，一定能无错误完成的接完SDK3、SDK的代码要可以复制的，不要用截图 十一、写一个检查接入SDK的检查事项写一个检查接入SDK的检查事项告诉开发者注意事项和常见问题 其他如果功能非常的多，可以考虑分包。 参考地址","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"SDK","slug":"SDK","permalink":"http://yoursite.com/tags/SDK/"}]},{"title":"iOS 内购（ IAP）处理流程（漏单）","slug":"2016/iOS/iOS内购漏单处理","date":"2016-02-23T16:00:00.000Z","updated":"2019-12-09T12:45:46.534Z","comments":true,"path":"2016/02/24/2016/iOS/iOS内购漏单处理/","link":"","permalink":"http://yoursite.com/2016/02/24/2016/iOS/iOS%E5%86%85%E8%B4%AD%E6%BC%8F%E5%8D%95%E5%A4%84%E7%90%86/","excerpt":"iOS 内购（ IAP）处理流程（漏单）最重要的一点：在 确认 服务端收到 receipt 之前(或者说确认玩家收到物品前)客户端不要结束订单（不要调用 [[SKPaymentQueue defaultQueue] finishTransaction:transaction]; 这边介绍的是服务端验证的内购 漏单漏单：玩家支付完成了却没有收到物品、且自己的服务端没有任何记录 iOS 的订单。iOS 的补单是非常麻烦的，用户提供支付的截图中的订单号我们又不能在苹果 Connect 或者其他地方找到相应的订单号。","text":"iOS 内购（ IAP）处理流程（漏单）最重要的一点：在 确认 服务端收到 receipt 之前(或者说确认玩家收到物品前)客户端不要结束订单（不要调用 [[SKPaymentQueue defaultQueue] finishTransaction:transaction]; 这边介绍的是服务端验证的内购 漏单漏单：玩家支付完成了却没有收到物品、且自己的服务端没有任何记录 iOS 的订单。iOS 的补单是非常麻烦的，用户提供支付的截图中的订单号我们又不能在苹果 Connect 或者其他地方找到相应的订单号。 购买步骤我们这边的处理步骤 12345678910111213141、向苹果服务器请求商品信息（可以在启动 App 的时候请求）2、手机端向自己服务器发送订单请求（生成我们平台自己的订单号）3、向苹果发送购买请求、且把自己的订单赋值给 payment.applicationUsername （iOS7之后）4、用户支付完成（网上很多例子在这边调用 finishTransaction、会造成一定量的漏单）5、把 receipt 和自己的订单号发送到自己的服务器验6、服务端向苹果发送验证7、本地收到服务端确定收到 receipt 的信息、及物品是否下发、调用结束购买 [[SKPaymentQueue defaultQueue] finishTransaction:transaction]; 注意： 1、自己的订单号：是根据苹果的productid和服务端其他一些信息制作而成，通过productid可以知道用户购买的时间、价格、物品等信息 2、finishTransaction：没有调用之前，成功购买的订单会一直留在[SKPaymentQueue defaultQueue]，且每次应用进入前台，都会调用支付完成的流程（前提是注册了addTransactionObserver 的观察者）苹果建议在物品真正发放后在调用 finishTransaction。文档查看 3、流程中第3步，iOS6 是不能使用 payment.applicationUsername，我这边是这样子处理把自己的 orderid 和 productIdentifier（为 key ）对应，存于一个自定义的 plist 中。这样在漏单的情况下，自己的 orderid 和 productIdentifier 即使不会一一对应，也可以确保 orderid 的套餐和价钱不会变 4、在购买的过程中（从用户发起购买请求到用户收到物品），只有一个订单在处理中，即用户完成了一单才再能购买下一单 5、现在从后台的记录看，iOS6 用户的充值是非常的少，（2015年12月29日）近3个月已经没有iOS6版本充值了记录了 服务器端服务端需要处理一个receipt中携带了多个未处理的订单，即在in-app中有多个支付记录。因为虽然按正常逻辑，一次只会处理一笔支付，在漏掉以前充值订单的情况下，一个receipt，可能含有多个购买记录，这些记录可能就是没有下发给用户的，需要对receipt 的 in-app记录逐条检查，根据订单记录查看某一单是否已经下发过了。 2016年02月24日16:00:26更新按上面支付流程上线后，发现还有问题，就是步骤第2步的时候，把自己的订单号存在payment.applicationUsername，有一些特殊情况会导致payment.applicationUsername为空，这里有人碰到过，我发现我们的后台日志也有这种情况， 这就需要在payment.applicationUsername为空的时候，使用其他方式获取刚刚从服务器获取的订单号(我这边是使用上次存在本地的订单号)或者重新请求自己的服务端重新生成订单号。 一些参考地址 [In-App Purchase Programming Guide] [In-App Purchase Best Practices] [Receipt Fields] [in-app is empty] Adding In-App Purchase to your Applications [In-App Purchase FAQ] 如果有朋友有比较好的建议，请告诉我下","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"IAP","slug":"IAP","permalink":"http://yoursite.com/tags/IAP/"},{"name":"SDK","slug":"SDK","permalink":"http://yoursite.com/tags/SDK/"}]}]}